From 2f7c9f0e3d3a1063be5dfe60a4317f45805b0fd2 Mon Sep 17 00:00:00 2001
From: darklord4822 <darklord4722@gmail.com>
Date: Sat, 10 Feb 2018 22:52:19 +0000
Subject: [PATCH] changes for MTK

Change-Id: I7f02293cb22415ae208536744fc0e8320751f72d
---
 include/media/AudioSystem.h                        |   8 +
 include/media/IAudioFlinger.h                      |   8 +
 include/media/IAudioPolicyService.h                |   2 +
 include/media/IOMX.h                               |   7 +
 include/media/stagefright/CameraSource.h           |   4 +
 media/libmedia/AudioSystem.cpp                     | 108 +++++++
 media/libmedia/IAudioFlinger.cpp                   | 213 +++++++++++++
 media/libmedia/IAudioPolicyService.cpp             |  30 +-
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  28 ++
 media/libstagefright/ACodec.cpp                    |  58 ++++
 media/libstagefright/Android.mk                    |   6 +
 media/libstagefright/CameraSource.cpp              |  27 ++
 media/libstagefright/colorconversion/Android.mk    |   2 +
 media/libstagefright/omx/OMX.cpp                   |  18 ++
 .../omx/SoftVideoDecoderOMXComponent.cpp           |  13 +
 services/audioflinger/AudioFlinger.cpp             | 170 ++++++++++
 services/audioflinger/AudioFlinger.h               |  11 +-
 services/audioflinger/Threads.cpp                  |   2 +
 services/audiopolicy/Android.mk                    |  27 ++
 services/audiopolicy/AudioPolicyInterface.h        |   4 +
 .../common/managerdefinitions/Android.mk           |   9 +
 .../engine/interface/AudioPolicyManagerObserver.h  |   3 +
 services/audiopolicy/enginedefault/Android.mk      |   9 +
 services/audiopolicy/enginedefault/src/Engine.cpp  |   9 +
 .../managerdefault/AudioPolicyManager.cpp          | 343 +++++++++++++++++++++
 .../managerdefault/AudioPolicyManager.h            |  22 ++
 .../audiopolicy/service/AudioPolicyClientImpl.cpp  |   9 +
 .../service/AudioPolicyInterfaceImpl.cpp           |  14 +
 .../audiopolicy/service/AudioPolicyService.cpp     |  49 ++-
 services/audiopolicy/service/AudioPolicyService.h  |  14 +
 30 files changed, 1224 insertions(+), 3 deletions(-)

diff --git a/include/media/AudioSystem.h b/include/media/AudioSystem.h
index 268791e..86c64c1 100644
--- a/include/media/AudioSystem.h
+++ b/include/media/AudioSystem.h
@@ -474,6 +474,14 @@ private:
     static audio_channel_mask_t gPrevInChannelMask;
 
     static sp<IAudioPolicyService> gAudioPolicyService;
+    // for AM mode set/get  parameters
+    public:
+    static status_t GetEMParameter(void *ptr,size_t len);
+    static status_t SetEMParameter(void *ptr,size_t len);
+    static status_t SetAudioCommand(int par1,int par2);
+    static status_t GetAudioCommand(int par1, int *par2);
+    static status_t SetAudioData(int par1,size_t len, void *ptr);
+    static status_t GetAudioData(int par1,size_t len,void *ptr);
 };
 
 };  // namespace android
diff --git a/include/media/IAudioFlinger.h b/include/media/IAudioFlinger.h
index 096f7ef..64152dd 100644
--- a/include/media/IAudioFlinger.h
+++ b/include/media/IAudioFlinger.h
@@ -245,6 +245,14 @@ public:
 
     // Returns the number of frames per audio HAL buffer.
     virtual size_t frameCountHAL(audio_io_handle_t ioHandle) const = 0;
+    
+    // get EM parameter
+    virtual status_t GetEMParameter(void *ptr, size_t len) = 0;
+    virtual status_t SetEMParameter(void *ptr, size_t len) = 0;
+    virtual status_t SetAudioCommand(int parameters1, int parameter2) = 0;
+    virtual status_t GetAudioCommand(int parameters1) = 0;
+    virtual status_t SetAudioData(int par1,size_t len,void *ptr)=0;
+    virtual status_t GetAudioData(int par1,size_t len,void *ptr)=0;
 };
 
 
diff --git a/include/media/IAudioPolicyService.h b/include/media/IAudioPolicyService.h
index 06bf4b8..06b40d2 100644
--- a/include/media/IAudioPolicyService.h
+++ b/include/media/IAudioPolicyService.h
@@ -123,6 +123,8 @@ public:
    // Check if offload is possible for given format, stream type, sample rate,
     // bit rate, duration, video and streaming or offload property is enabled
     virtual bool isOffloadSupported(const audio_offload_info_t& info) = 0;
+    
+    virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4) = 0;
 
     /* List available audio ports and their attributes */
     virtual status_t listAudioPorts(audio_port_role_t role,
diff --git a/include/media/IOMX.h b/include/media/IOMX.h
index 1c39b9c..cda2204 100644
--- a/include/media/IOMX.h
+++ b/include/media/IOMX.h
@@ -233,6 +233,13 @@ struct omx_message {
             OMX_U32 range_length;
             OMX_U32 flags;
             OMX_TICKS timestamp;
+#ifdef MTK_HARDWARE
+            //for transmitting proprietary data
+            OMX_U32 token_tick;
+            OMX_U32 token_VA;
+            OMX_U32 token_PA;
+            OMX_U32 token_FD;
+#endif
         } extended_buffer_data;
 
         // if type == FRAME_RENDERED
diff --git a/include/media/stagefright/CameraSource.h b/include/media/stagefright/CameraSource.h
index c2e75a6..31afc33 100644
--- a/include/media/stagefright/CameraSource.h
+++ b/include/media/stagefright/CameraSource.h
@@ -317,6 +317,10 @@ private:
     CameraSource &operator=(const CameraSource &);
 };
 
+#ifdef MTK_HARDWARE
+int32_t getColorFormatByMTK(const char* colorFormat);
+#endif
+
 }  // namespace android
 
 #endif  // CAMERA_SOURCE_H_
diff --git a/media/libmedia/AudioSystem.cpp b/media/libmedia/AudioSystem.cpp
index 35d3a7c..a4f8fa2 100644
--- a/media/libmedia/AudioSystem.cpp
+++ b/media/libmedia/AudioSystem.cpp
@@ -26,6 +26,9 @@
 
 #include <system/audio.h>
 
+#include <AudioPolicyParameters.h>
+#include <AudioMTKHardwareCommand.h>
+
 // ----------------------------------------------------------------------------
 
 namespace android {
@@ -1335,4 +1338,109 @@ void AudioSystem::AudioPolicyServiceClient::binderDied(const wp<IBinder>& who __
     ALOGW("AudioPolicyService server died!");
 }
 
+//add , for EM mode
+status_t AudioSystem::GetEMParameter(void *ptr,size_t len)
+{
+#ifdef MTK_HARDWARE
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->GetEMParameter(ptr,len);
+#endif
+    return OK;
+}
+
+status_t AudioSystem::SetEMParameter(void *ptr,size_t len)
+{
+#ifdef MTK_HARDWARE
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0) return PERMISSION_DENIED;
+    return af->SetEMParameter(ptr,len);
+#endif
+}
+
+status_t AudioSystem::SetAudioCommand(int par1,int par2)
+{
+#ifdef MTK_HARDWARE
+    status_t af_status;
+    ALOGD("AudioSystem::SetAudioCommand");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::SetAudioCommand Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    af_status = af->SetAudioCommand(par1,par2);
+
+    if (par1 == SET_LOAD_VOLUME_SETTING)
+    {
+        const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+        if(aps != 0)
+        {
+            aps->SetPolicyManagerParameters (POLICY_LOAD_VOLUME,0,0,0);
+        }
+    }
+
+    return af_status;
+
+#endif
+    return OK;
+}
+
+status_t AudioSystem::GetAudioCommand(int par1,int* par2)
+{
+#ifdef MTK_HARDWARE
+    ALOGD("AudioSystem::GetAudioCommand");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::GetAudioCommand Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    *par2 =  af->GetAudioCommand(par1);
+#endif
+    return NO_ERROR;
+}
+
+status_t AudioSystem::SetAudioData(int par1,size_t byte_len,void *ptr)
+{
+#ifdef MTK_HARDWARE
+    status_t af_status;
+    ALOGD("SetAudioData");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::SetAAudioData Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    af_status = af->SetAudioData(par1,byte_len,ptr);
+
+    if (par1 == SET_AUDIO_VER1_DATA)
+    {
+        const sp<IAudioPolicyService>& aps = AudioSystem::get_audio_policy_service();
+        if(aps != 0)
+        {
+            aps->SetPolicyManagerParameters (POLICY_LOAD_VOLUME,0,0,0);
+        }
+    }
+
+    return af_status;
+#endif
+    return OK;
+}
+
+status_t AudioSystem::GetAudioData(int par1,size_t byte_len,void *ptr)
+{
+#ifdef MTK_HARDWARE
+    ALOGD("GetAudioData");
+    const sp<IAudioFlinger>& af = AudioSystem::get_audio_flinger();
+    if (af == 0)
+    {
+        ALOGE("AudioSystem::GetAAudioData Error!! PERMISSION_DENIED");
+        return PERMISSION_DENIED;
+    }
+    return af->GetAudioData(par1,byte_len,ptr);
+#endif
+    return OK;
+}
+
 } // namespace android
diff --git a/media/libmedia/IAudioFlinger.cpp b/media/libmedia/IAudioFlinger.cpp
index 900d418..c6f3916 100644
--- a/media/libmedia/IAudioFlinger.cpp
+++ b/media/libmedia/IAudioFlinger.cpp
@@ -83,6 +83,14 @@ enum {
     GET_AUDIO_HW_SYNC,
     SYSTEM_READY,
     FRAME_COUNT_HAL,
+    #ifdef MTK_HARDWARE
+    GET_EM_PARAMETER  = 0x7FFF0000,  //Don't call by CTS for security
+    SET_EM_PARAMETER,
+    SET_AUDIO_COMMAND,
+    GET_AUDIO_COMMAND,
+    SET_AUDIO_DATA,
+    GET_AUDIO_DATA,
+#endif
 };
 
 #define MAX_ITEMS_PER_LIST 1024
@@ -929,6 +937,90 @@ public:
         }
         return reply.readInt64();
     }
+#ifdef MTK_HARDWARE
+    virtual status_t GetEMParameter(void *ptr, size_t len)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(len);
+        data.write(ptr,len);
+        remote()->transact(GET_EM_PARAMETER, data, &reply);
+        reply.read(ptr, len);
+        return OK;
+    }
+    virtual status_t SetEMParameter(void *ptr, size_t len)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(len);
+        data.write(ptr,len);
+        remote()->transact(SET_EM_PARAMETER, data, &reply);
+        reply.read(ptr, len);
+        return OK;
+    }
+    virtual status_t SetAudioCommand(int var1,int var2)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(var1);
+        data.writeInt32(var2);
+        remote()->transact(SET_AUDIO_COMMAND, data, &reply);
+        return  reply.readInt32();
+    }
+    virtual status_t GetAudioCommand(int var1)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(var1);
+        remote()->transact(GET_AUDIO_COMMAND, data, &reply);
+        return  reply.readInt32();
+    }
+    virtual status_t SetAudioData(int par1, size_t len, void *ptr)
+    {
+        Parcel data, reply;
+        if (ptr == NULL || len > 16384) {
+            return BAD_VALUE;
+        }
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(len);
+        if (len > 0) {
+            data.write(ptr, len);
+        }
+        status_t lStatus = remote()->transact(SET_AUDIO_DATA, data, &reply);
+        if (lStatus != NO_ERROR) {
+            ALOGE("SetAudioData error: %s", strerror(-lStatus));
+        } else {
+            if (len > 0) {
+                reply.read(ptr, len);
+            }
+        }
+        return reply.readInt32();
+    }
+
+    virtual status_t GetAudioData(int par1, size_t len, void *ptr)
+    {
+        Parcel data, reply;
+        if (ptr == NULL || len > 16384) {
+            return BAD_VALUE;
+        }
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(len);
+        if (len > 0) {
+            data.write(ptr, len);
+        }
+        status_t lStatus = remote()->transact(GET_AUDIO_DATA, data, &reply);
+        if (lStatus != NO_ERROR) {
+            ALOGE("GetAudioData error: %s", strerror(-lStatus));
+        } else {
+            if (len > 0) {
+                reply.read(ptr, len);
+            }
+        }
+        return reply.readInt32();
+    }
+#endif
 
 };
 
@@ -1449,6 +1541,127 @@ status_t BnAudioFlinger::onTransact(
             reply->writeInt64( frameCountHAL((audio_io_handle_t) data.readInt32()) );
             return NO_ERROR;
         } break;
+#ifdef MTK_HARDWARE
+        // for EM mode Setting
+        case GET_EM_PARAMETER:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t size = data.readInt32();
+            void *params = malloc(size);
+            data.read(params, size);
+            status_t err = GetEMParameter(params,size);
+            if (err == NO_ERROR){
+                reply->write( params,size);
+            }
+            free(params);
+            return NO_ERROR;
+        }break;
+        case SET_EM_PARAMETER:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t size = data.readInt32();
+            void *params = malloc(size);
+            data.read(params, size);
+            status_t err = SetEMParameter(params,size);
+            if (err == NO_ERROR){
+                reply->write(params,size);
+            }
+            free(params);
+            return NO_ERROR;
+        }break;
+        case SET_AUDIO_COMMAND:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t command1 = data.readInt32();
+            int32_t command2 = data.readInt32();
+            reply->writeInt32(SetAudioCommand(command1,command2));
+            return NO_ERROR;
+        }break;
+        case GET_AUDIO_COMMAND:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t command1 = data.readInt32();
+            reply->writeInt32(GetAudioCommand(command1));
+            return NO_ERROR;
+        }break;
+#if 0
+        case SET_AUDIO_DATA:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            void *params = malloc(buf_size);
+            data.read(params, buf_size);
+            status_t err = SetAudioData(command,buf_size,params);
+            reply->write(params,buf_size);
+            free(params);
+            return NO_ERROR;
+        }break;
+        case GET_AUDIO_DATA:
+        {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            void *params = malloc(buf_size);
+            data.read(params, buf_size);
+            status_t err = GetAudioData(command,buf_size,params);
+            reply->write(params,buf_size);
+            free(params);
+            return NO_ERROR;
+        }break;
+#else   //Sync Sprout modification
+        case SET_AUDIO_DATA: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            if (buf_size > 16384) {
+                reply->writeInt32(BAD_VALUE);
+                return BAD_VALUE;
+            }
+            void *params = NULL;
+            if (buf_size > 0) {
+                params = malloc(buf_size);
+                if (params == NULL) {
+                    reply->writeInt32(BAD_VALUE);
+                    return BAD_VALUE;
+                }
+                data.read(params, buf_size);
+            }
+            status_t status = SetAudioData(command, buf_size, params);
+            if (params != NULL) {
+                reply->write(params, buf_size);
+                free(params);
+            }
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+        case GET_AUDIO_DATA: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            size_t command = data.readInt32();
+            size_t buf_size = data.readInt32();
+            if (buf_size > 16384) {
+                reply->writeInt32(BAD_VALUE);
+                return BAD_VALUE;
+            }
+            void *params = NULL;
+            if (buf_size > 0) {
+                params = malloc(buf_size);
+                if (params == NULL) {
+                    reply->writeInt32(BAD_VALUE);
+                    return BAD_VALUE;
+                }
+                data.read(params, buf_size);
+            }
+            status_t status = GetAudioData(command, buf_size, params);
+            if (params != NULL) {
+                reply->write(params, buf_size);
+                free(params);
+            }
+            reply->writeInt32(status);
+            return NO_ERROR;
+        } break;
+#endif
+#endif
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/media/libmedia/IAudioPolicyService.cpp b/media/libmedia/IAudioPolicyService.cpp
index 2dd1611..05fc3e9 100644
--- a/media/libmedia/IAudioPolicyService.cpp
+++ b/media/libmedia/IAudioPolicyService.cpp
@@ -76,6 +76,9 @@ enum {
     SET_AUDIO_PORT_CALLBACK_ENABLED,
     SET_MASTER_MONO,
     GET_MASTER_MONO,
+#ifdef MTK_HARDWARE
+    SET_POLICYMANAGER_PARAMETERS,
+#endif
     LIST_AUDIO_SESSIONS,
 };
 
@@ -510,6 +513,20 @@ public:
         return status;
     }
 
+#ifdef MTK_HARDWARE
+    virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioPolicyService::getInterfaceDescriptor());
+        data.writeInt32(par1);
+        data.writeInt32(par2);
+        data.writeInt32(par3);
+        data.writeInt32(par4);
+        remote()->transact(SET_POLICYMANAGER_PARAMETERS, data, &reply);
+        return static_cast <status_t> (reply.readInt32());
+    }
+#endif
+
     virtual bool isOffloadSupported(const audio_offload_info_t& info)
     {
         Parcel data, reply;
@@ -1164,7 +1181,18 @@ status_t BnAudioPolicyService::onTransact(
             delete[] descriptors;
             return status;
         }
-
+        
+#ifdef MTK_HARDWARE
+        case SET_POLICYMANAGER_PARAMETERS: {
+            CHECK_INTERFACE(IAudioPolicyService, data, reply);
+            int par1 =data.readInt32();
+            int par2 =data.readInt32();
+            int par3 =data.readInt32();
+            int par4 =data.readInt32();
+            reply->writeInt32(SetPolicyManagerParameters(par1,par2,par3,par4));
+            return NO_ERROR;
+        } break;
+#endif
         case IS_OFFLOAD_SUPPORTED: {
             CHECK_INTERFACE(IAudioPolicyService, data, reply);
             audio_offload_info_t info;
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index a6558ab..b1d107d 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -936,6 +936,14 @@ status_t StagefrightRecorder::start() {
 }
 
 sp<MediaCodecSource> StagefrightRecorder::createAudioSource() {
+#ifdef MTK_HARDWARE
+    //MTK80721 HDRecord 2011-12-23
+    if ((mAudioEncoder == AUDIO_ENCODER_AAC || mAudioEncoder == AUDIO_ENCODER_HE_AAC || mAudioEncoder == AUDIO_ENCODER_AAC_ELD) && mSampleRate < 16000)
+    {
+        ALOGD("encode profile tuning:encode:%d,samplerate:%d,min smplerate=16K",mAudioEncoder, mSampleRate);
+        mSampleRate = 16000;
+    }
+#endif
     int32_t sourceSampleRate = mSampleRate;
 
     if (mCaptureFpsEnable && mCaptureFps >= mFrameRate) {
@@ -1832,9 +1840,22 @@ status_t StagefrightRecorder::pause() {
         return OK;
     }
 
+#ifdef MTK_HARDWARE
+    if((mOutputFormat == OUTPUT_FORMAT_AMR_NB ||
+          mOutputFormat == OUTPUT_FORMAT_AMR_WB)
+          &&mAudioEncoderSource != NULL){
+            ALOGW("AMR will pause writer for support stop after pause");
+            mWriter->pause();
+    }else{
     if (mAudioEncoderSource != NULL) {
         mAudioEncoderSource->pause();
     }
+    }
+#else
+    if (mAudioEncoderSource != NULL) {
+        mAudioEncoderSource->pause();
+    }
+#endif
     if (mVideoEncoderSource != NULL) {
         mVideoEncoderSource->pause();
     }
@@ -1885,6 +1906,13 @@ status_t StagefrightRecorder::resume() {
         if (source == nullptr) {
             continue;
         }
+#ifdef MTK_HARDWARE
+        if (mOutputFormat == OUTPUT_FORMAT_AMR_NB || mOutputFormat == OUTPUT_FORMAT_AMR_WB) {
+            ALOGD("AMR Recording pause-resume");
+            mWriter->start();
+            continue;
+        }
+#endif
         source->setInputBufferTimeOffset((int64_t)timeOffset);
         source->start();
     }
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index a11494d..8c178c8 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -212,6 +212,35 @@ struct CodecObserver : public BnOMXObserver {
                             omx_msg.u.extended_buffer_data.timestamp);
                     msg->setInt32(
                             "fence_fd", omx_msg.fenceFd);
+#ifdef MTK_HARDWARE
+                    msg->setInt32(
+                            "ticks",
+                            omx_msg.u.extended_buffer_data.token_tick);
+                if( 0x00010000 == (0x00010000 & omx_msg.u.extended_buffer_data.flags) )
+                {
+                   msg->setInt32(
+                            "token_VA",
+                            omx_msg.u.extended_buffer_data.token_VA);
+                    msg->setInt32(
+                            "token_PA",
+                            omx_msg.u.extended_buffer_data.token_PA);
+                    msg->setInt32(
+                            "token_FD",
+                            omx_msg.u.extended_buffer_data.token_FD);
+                }
+                else
+                {
+                    msg->setInt32(
+                            "token_VA",
+                            0);
+                    msg->setInt32(
+                            "token_PA",
+                            0);
+                    msg->setInt32(
+                            "token_FD",
+                            0);
+                }
+#endif
                     break;
                 }
 
@@ -2768,6 +2797,12 @@ status_t ACodec::setupAACCodec(
     if (encoder && isADTS) {
         return -EINVAL;
     }
+#ifdef MTK_HARDWARE  //Error handling for WhatsApp issue.
+    if (encoder && sampleRate == 44000)
+    {
+        sampleRate = 44100;
+    }
+#endif
 
     status_t err = setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
@@ -3899,7 +3934,20 @@ status_t ACodec::setupVideoEncoder(
 
     video_def->nSliceHeight = sliceHeight;
 
+#ifdef MTK_HARDWARE //for continus shot feature
+    ALOGD("nStride %d, nSliceHeight %d", video_def->nStride, video_def->nSliceHeight);
+    //support RGB565 and RGB888 size
+    if( colorFormat == OMX_COLOR_Format16bitRGB565 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 2);
+    else if( colorFormat == OMX_COLOR_Format24bitRGB888 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3);
+    else if( colorFormat == OMX_COLOR_Format32bitARGB8888 )
+        def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 4);
+    else
     def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3) / 2;
+#else
+    def.nBufferSize = (video_def->nStride * video_def->nSliceHeight * 3) / 2;
+#endif
 
     float frameRate;
     if (!msg->findFloat("frame-rate", &frameRate)) {
@@ -5141,6 +5189,16 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                             rect.nWidth = videoDef->nFrameWidth;
                             rect.nHeight = videoDef->nFrameHeight;
                         }
+#ifdef MTK_HARDWARE
+                    if (!strncmp(mComponentName.c_str(), "OMX.MTK.", 8) && mOMX->getConfig(
+                            mNode, (OMX_INDEXTYPE) 0x7f00001c /* OMX_IndexVendorMtkOmxVdecGetCropInfo */,
+                            &rect, sizeof(rect)) != OK) {
+                        rect.nLeft = 0;
+                        rect.nTop = 0;
+                        rect.nWidth = videoDef->nFrameWidth;
+                        rect.nHeight = videoDef->nFrameHeight;
+                    }
+#endif
 
                         if (rect.nLeft < 0 ||
                             rect.nTop < 0 ||
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index e708f68..8c313f7 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -202,6 +202,12 @@ LOCAL_C_INCLUDES += \
 	$(TOP)/hardware/samsung/exynos4/include
 endif
 
+ifeq ($(strip $(BOARD_USES_MTK_HARDWARE)),true)
+LOCAL_SHARED_LIBRARIES += \
+    libdpframework \
+	libmtkcam_fwkutils
+endif
+
 LOCAL_MODULE:= libstagefright
 
 LOCAL_MODULE_TAGS := optional
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 8707d96..0184c73 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -43,6 +43,9 @@
 #else
 #define UNUSED_UNLESS_VERBOSE(x)
 #endif
+#ifdef MTK_HARDWARE
+#include "MtkCameraParameters.h"
+#endif
 
 namespace android {
 
@@ -113,10 +116,21 @@ void CameraSourceListener::postRecordingFrameHandleTimestamp(nsecs_t timestamp,
 }
 
 static int32_t getColorFormat(const char* colorFormat) {
+#ifdef MTK_HARDWARE
+    if(colorFormat == NULL){
+        ALOGW("camera colorFrmat is NULL!");
+        return -1;
+    }
+    int32_t result = getColorFormatByMTK(colorFormat);
+    if(result != -1){
+        return result;
+    }
+#else
     if (!colorFormat) {
         ALOGE("Invalid color format");
         return -1;
     }
+#endif
 
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P)) {
        return OMX_COLOR_FormatYUV420Planar;
@@ -1337,4 +1351,17 @@ void CameraSource::DeathNotifier::binderDied(const wp<IBinder>& who __unused) {
     ALOGI("Camera recording proxy died");
 }
 
+#ifdef MTK_HARDWARE
+int32_t getColorFormatByMTK(const char* colorFormat) {
+    ALOGD("getColorFormat(%s)", colorFormat);
+    if (!strcmp(colorFormat, MtkCameraParameters::PIXEL_FORMAT_YUV420I)) {
+       return OMX_COLOR_FormatYUV420Planar; // i420
+    }
+    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420P) ) {
+       return OMX_MTK_COLOR_FormatYV12;// YV12
+    }
+    return -1;
+}
+#endif
+
 }  // namespace android
diff --git a/media/libstagefright/colorconversion/Android.mk b/media/libstagefright/colorconversion/Android.mk
index 0bf9701..904fa68 100644
--- a/media/libstagefright/colorconversion/Android.mk
+++ b/media/libstagefright/colorconversion/Android.mk
@@ -1,4 +1,5 @@
 LOCAL_PATH:= $(call my-dir)
+ifneq ($(strip $(BOARD_USES_MTK_HARDWARE)),true)
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=                     \
@@ -20,3 +21,4 @@ LOCAL_SANITIZE := signed-integer-overflow
 LOCAL_MODULE:= libstagefright_color_conversion
 
 include $(BUILD_STATIC_LIBRARY)
+endif
\ No newline at end of file
diff --git a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
index d6fb2b2..fec6630 100644
--- a/media/libstagefright/omx/OMX.cpp
+++ b/media/libstagefright/omx/OMX.cpp
@@ -724,6 +724,24 @@ OMX_ERRORTYPE OMX::OnFillBufferDone(
     msg.u.extended_buffer_data.range_length = pBuffer->nFilledLen;
     msg.u.extended_buffer_data.flags = pBuffer->nFlags;
     msg.u.extended_buffer_data.timestamp = pBuffer->nTimeStamp;
+#ifdef MTK_HARDWARE
+    //for transmitting proprietary data
+    msg.u.extended_buffer_data.token_tick = pBuffer->nTickCount;
+    msg.u.extended_buffer_data.token_VA = 0;
+    msg.u.extended_buffer_data.token_PA = 0;
+    msg.u.extended_buffer_data.token_FD = 0;
+    if( 0x00010000 == (0x00010000 & pBuffer->nFlags) )
+    {
+        //OMX_U32 CMInfo[0x8] = {0};
+        OMX_U32 *CMPtr = (OMX_U32 *)pBuffer->pPlatformPrivate;
+        if( NULL != pBuffer->pPlatformPrivate )
+        {
+           msg.u.extended_buffer_data.token_VA = *(CMPtr+2);
+            msg.u.extended_buffer_data.token_PA = *(CMPtr+3);
+            msg.u.extended_buffer_data.token_FD = *(CMPtr+7);
+        }
+    }
+#endif
 
     sp<OMX::CallbackDispatcher> callbackDispatcher = findDispatcher(node);
     if (callbackDispatcher != NULL) {
diff --git a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
index 409cef7..3591eee 100644
--- a/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
+++ b/media/libstagefright/omx/SoftVideoDecoderOMXComponent.cpp
@@ -488,6 +488,18 @@ OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalSetParameter(
             uint32_t oldHeight = def->format.video.nFrameHeight;
             uint32_t newWidth = video_def->nFrameWidth;
             uint32_t newHeight = video_def->nFrameHeight;
+#ifdef MTK_HARDWARE
+            // 20150126 Marcus Huang: Fix ALPS01919422; limits the max width/height
+            //@Vdec_drv_if_public.c
+            //  DEC_MAX_WIDTH = 1920;
+            //  DEC_MAX_HEIGHT = 1088;
+#define MAX_SUPPORT_WIDTH 1920
+#define MAX_SUPPORT_HEIGHT 1088
+            if ((newWidth * newHeight) > (MAX_SUPPORT_WIDTH * MAX_SUPPORT_HEIGHT)) {
+                ALOGE("frame size is not supported (%d x %d)", newWidth, newHeight);
+                return OMX_ErrorUnsupportedSetting;
+            }
+#else
             // We need width, height, stride and slice-height to be non-zero and sensible.
             // These values were chosen to prevent integer overflows further down the line, and do
             // not indicate support for 32kx32k video.
@@ -496,6 +508,7 @@ OMX_ERRORTYPE SoftVideoDecoderOMXComponent::internalSetParameter(
                 ALOGE("b/22885421");
                 return OMX_ErrorBadParameter;
             }
+#endif
             if (newWidth != oldWidth || newHeight != oldHeight) {
                 bool outputPort = (newParams->nPortIndex == kOutputPortIndex);
                 if (outputPort) {
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 9244e5b..a786301 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -60,6 +60,9 @@
 
 #include <system/audio.h>
 #include <hardware/audio.h>
+#ifdef MTK_HARDWARE
+#include <audio_mtk.h>
+#endif
 
 #include "AudioMixer.h"
 #include "AudioFlinger.h"
@@ -128,6 +131,173 @@ size_t AudioFlinger::mTeeSinkTrackFrames = kTeeSinkTrackFramesDefault;
 static const nsecs_t kMinGlobalEffectEnabletimeNs = seconds(7200);
 
 // ----------------------------------------------------------------------------
+// support EM mode setting
+#ifdef MTK_HARDWARE
+status_t AudioFlinger::SetEMParameter(void *ptr, size_t len)
+{
+    ALOGV("SetEMParameter ");
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    audio_hw_device_mtk_t *dev = (audio_hw_device_mtk_t*) mPrimaryHardwareDev->hwDevice();
+
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    if (NULL == dev->SetEMParameter)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->SetEMParameter(dev,ptr,len);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::GetEMParameter(void *ptr, size_t len)
+{
+    ALOGV("GetEMParameter ");
+    // ioHandle == 0 means the parameters are global to the audio hardware interface
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->GetEMParameter)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->GetEMParameter(dev,ptr,len);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::SetAudioData(int par1,size_t len,void *ptr)
+{
+    ALOGV("SetAudioData par1 = %d,len = %zu ", par1, len);
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->SetAudioData)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->SetAudioData(dev,par1,len,ptr);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::GetAudioData(int par1,size_t len,void *ptr)
+{
+    ALOGV("GetAudioData par1 = %d,len = %zu ", par1, len);
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->GetAudioData)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->GetAudioData(dev,par1,len,ptr);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::SetAudioCommand(int parameters1,int parameters2)
+{
+    ALOGV("SetAudioCommand par1 = %d,par2 = %d ",parameters1,parameters2);
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->SetAudioCommand)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    dev->SetAudioCommand(dev,parameters1,parameters2);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return NO_ERROR;
+}
+
+status_t AudioFlinger::GetAudioCommand(int parameters1)
+{
+    ALOGV("GetAudioCommand par1 = %d",parameters1);
+    int value =0;
+    AutoMutex lock(mHardwareLock);
+    if (NULL == mPrimaryHardwareDev)
+    {
+        ALOGE("%s mPrimaryHardwareDev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    audio_hw_device_mtk_t *dev = static_cast<audio_hw_device_mtk_t*>(mPrimaryHardwareDev->hwDevice());
+    if (NULL == dev)
+    {
+        ALOGE("%s dev is null",__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+    if (NULL == dev->GetAudioCommand)
+    {
+        ALOGE("%s dev->%s is null",__FUNCTION__,__FUNCTION__);
+        return INVALID_OPERATION;
+    }
+
+    mHardwareStatus = AUDIO_HW_SET_PARAMETER;
+    value =dev->GetAudioCommand(dev,parameters1);
+    mHardwareStatus = AUDIO_HW_IDLE;
+    return value;
+}
+#endif
+
+// ----------------------------------------------------------------------------
 
 const char *formatToString(audio_format_t format) {
     switch (audio_get_main_format(format)) {
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index a417754..e50dbd6 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -116,7 +116,16 @@ class AudioFlinger :
     friend class BinderService<AudioFlinger>;   // for AudioFlinger()
 public:
     static const char* getServiceName() ANDROID_API { return "media.audio_flinger"; }
-
+    
+// add to EM mode setting
+#ifdef MTK_HARDWARE
+    virtual status_t GetEMParameter(void *ptr, size_t len);
+    virtual status_t SetEMParameter(void *ptr, size_t len);
+    virtual status_t SetAudioData(int par1,size_t len,void *ptr);
+    virtual status_t GetAudioData(int par1,size_t len,void *ptr);
+    virtual status_t SetAudioCommand(int parameters1,int parameters2);
+    virtual status_t GetAudioCommand(int parameters1);
+#endif
     virtual     status_t    dump(int fd, const Vector<String16>& args);
 
     // IAudioFlinger interface, in binder opcode order
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index e8c80c1..6147603 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -6462,6 +6462,7 @@ reacquire_wakelock:
         mTimestamp.mPosition[ExtendedTimestamp::LOCATION_SERVER] += framesRead;
         mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_SERVER] = systemTime();
 
+#ifndef MTK_HARDWARE
         // Update server timestamp with kernel stats
         if (mInput->stream->get_capture_position != nullptr
                 && mPipeSource.get() == nullptr /* don't obtain for FastCapture, could block */) {
@@ -6477,6 +6478,7 @@ reacquire_wakelock:
                 // as the read obtains a lock, preventing the timestamp call from executing.
             }
         }
+#endif
         // Use this to track timestamp information
         // ALOGD("%s", mTimestamp.toString().c_str());
 
diff --git a/services/audiopolicy/Android.mk b/services/audiopolicy/Android.mk
index dc47235..266f650 100644
--- a/services/audiopolicy/Android.mk
+++ b/services/audiopolicy/Android.mk
@@ -70,6 +70,15 @@ endif
 # DOLBY_END
 LOCAL_CFLAGS += -Wall -Werror
 
+ifeq ($(BOARD_USES_MTK_HARDWARE),true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia \
+    libaudiocustparam
+
+endif
+
 include $(BUILD_SHARED_LIBRARY)
 
 ifneq ($(USE_LEGACY_AUDIO_POLICY), 1)
@@ -130,6 +139,15 @@ LOCAL_CFLAGS += -Wall -Werror
 
 LOCAL_MULTILIB := $(AUDIOSERVER_MULTILIB)
 
+ifeq ($(BOARD_USES_MTK_HARDWARE),true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia \
+    libaudiocustparam
+
+endif
+
 LOCAL_MODULE:= libaudiopolicymanagerdefault
 
 include $(BUILD_SHARED_LIBRARY)
@@ -160,6 +178,15 @@ LOCAL_CFLAGS := -Wall -Werror
 
 LOCAL_MULTILIB := $(AUDIOSERVER_MULTILIB)
 
+ifeq ($(BOARD_USES_MTK_HARDWARE),true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia \
+    libaudiocustparam
+
+endif
+
 LOCAL_MODULE:= libaudiopolicymanager
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/audiopolicy/AudioPolicyInterface.h b/services/audiopolicy/AudioPolicyInterface.h
index 2d7cbdd..5f6b23d 100644
--- a/services/audiopolicy/AudioPolicyInterface.h
+++ b/services/audiopolicy/AudioPolicyInterface.h
@@ -22,6 +22,7 @@
 #include <utils/String8.h>
 
 #include <hardware/audio_policy.h>
+#include <AudioCustomVolume.h>
 
 namespace android {
 
@@ -228,6 +229,7 @@ public:
                                       audio_io_handle_t *handle,
                                       uid_t uid) = 0;
     virtual status_t stopAudioSource(audio_io_handle_t handle) = 0;
+    virtual status_t SetPolicyManagerParameters(int par1, int par2 , int par3 , int par4) = 0;
 
     virtual status_t setMasterMono(bool mono) = 0;
     virtual status_t getMasterMono(bool *mono) = 0;
@@ -342,6 +344,8 @@ public:
                     const struct audio_config_base *deviceConfig,
                     audio_patch_handle_t patchHandle) = 0;
     virtual void onOutputSessionEffectsUpdate(sp<AudioSessionInfo>& streamInfo, bool added) = 0;
+    
+    virtual status_t getCustomAudioVolume(void* pCustomVol) = 0;
 
 };
 
diff --git a/services/audiopolicy/common/managerdefinitions/Android.mk b/services/audiopolicy/common/managerdefinitions/Android.mk
index 69d84e4..eb75220 100644
--- a/services/audiopolicy/common/managerdefinitions/Android.mk
+++ b/services/audiopolicy/common/managerdefinitions/Android.mk
@@ -73,6 +73,15 @@ LOCAL_MULTILIB := $(AUDIOSERVER_MULTILIB)
 
 LOCAL_CFLAGS += -Wall -Werror
 
+ifeq ($(BOARD_USES_MTK_HARDWARE),true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia \
+    libaudiocustparam
+
+endif
+
 LOCAL_MODULE := libaudiopolicycomponents
 
 include $(BUILD_STATIC_LIBRARY)
diff --git a/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h b/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h
index 846fa48..8c40a26 100755
--- a/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h
+++ b/services/audiopolicy/engine/interface/AudioPolicyManagerObserver.h
@@ -26,6 +26,7 @@
 #include <AudioOutputDescriptor.h>
 #include <AudioPolicyMix.h>
 #include <SoundTriggerSession.h>
+#include <AudioPolicyVendorControl.h>
 
 namespace android {
 
@@ -54,6 +55,8 @@ public:
     virtual IVolumeCurvesCollection &getVolumeCurves() = 0;
 
     virtual const sp<DeviceDescriptor> &getDefaultOutputDevice() const = 0;
+    
+    virtual AudioPolicyVendorControl &getAudioPolicyVendorControl() = 0;
 
 protected:
     virtual ~AudioPolicyManagerObserver() {}
diff --git a/services/audiopolicy/enginedefault/Android.mk b/services/audiopolicy/enginedefault/Android.mk
index 543b82b..f53e711 100755
--- a/services/audiopolicy/enginedefault/Android.mk
+++ b/services/audiopolicy/enginedefault/Android.mk
@@ -49,5 +49,14 @@ LOCAL_SHARED_LIBRARIES += \
     libcutils \
     libutils \
     libaudioutils \
+    
+ifeq ($(BOARD_USES_MTK_HARDWARE),true)
+LOCAL_CFLAGS += -DMTK_HARDWARE
+
+LOCAL_SHARED_LIBRARIES += \
+    libmedia \
+    libaudiocustparam
+
+endif
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/audiopolicy/enginedefault/src/Engine.cpp b/services/audiopolicy/enginedefault/src/Engine.cpp
index 6db66b0..a0cb006 100755
--- a/services/audiopolicy/enginedefault/src/Engine.cpp
+++ b/services/audiopolicy/enginedefault/src/Engine.cpp
@@ -85,9 +85,18 @@ status_t Engine::setPhoneState(audio_mode_t state)
         ALOGV("  Entering call in setPhoneState()");
         mApmObserver->getVolumeCurves().switchVolumeCurve(AUDIO_STREAM_VOICE_CALL,
                                                           AUDIO_STREAM_DTMF);
+#ifdef MTK_HARDWARE
+        AudioPolicyVendorControl &mAudioPolicyVendorControl = mApmObserver->getAudioPolicyVendorControl();
+        mAudioPolicyVendorControl.setVoiceReplaceDTMFStatus(true);
+#endif
+                                                          
     } else if (is_state_in_call(oldState) && !is_state_in_call(state)) {
         ALOGV("  Exiting call in setPhoneState()");
         mApmObserver->getVolumeCurves().restoreOriginVolumeCurve(AUDIO_STREAM_DTMF);
+#ifdef MTK_HARDWARE
+        AudioPolicyVendorControl &mAudioPolicyVendorControl = mApmObserver->getAudioPolicyVendorControl();
+        mAudioPolicyVendorControl.setVoiceReplaceDTMFStatus(false);
+#endif
     }
     return NO_ERROR;
 }
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index 8c39f78..4ca2b93 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -67,8 +67,27 @@
 #ifdef DOLBY_ENABLE
 #include "DolbyAudioPolicy_impl.h"
 #endif // DOLBY_END
+#include <audio_mtk.h>
+#include <AudioPolicyParameters.h>
 
 namespace android {
+    
+// mtk start
+#ifndef VOICE_VOLUME_MAX
+#define VOICE_VOLUME_MAX       (160)
+#endif
+#ifndef VOICE_ONEDB_STEP
+#define VOICE_ONEDB_STEP         (4)
+#endif
+// debug
+#if 0
+#define MTK_ALOGVV(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
+#define MTK_ALOGV(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)
+#else
+#define MTK_ALOGVV(...) do { } while(0)
+#define MTK_ALOGV(...) do { } while(0)
+#endif
+// mtk end
 
 //FIXME: workaround for truncated touch sounds
 // to be removed when the problem is handled by system UI
@@ -3406,6 +3425,17 @@ AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterfa
                 if (mPrimaryOutput == 0 &&
                         outProfile->getFlags() & AUDIO_OUTPUT_FLAG_PRIMARY) {
                     mPrimaryOutput = outputDesc;
+		#ifdef MTK_HARDWARE
+                    mAudioCustVolumeTable.bRev = CUSTOM_VOLUME_REV_1;
+                    mAudioCustVolumeTable.bReady = 0;
+                    mpClientInterface->getCustomAudioVolume(&mAudioCustVolumeTable);
+                    if (mAudioCustVolumeTable.bReady!=0) {
+                        ALOGD("mUseCustomVolume true");
+                        mAudioPolicyVendorControl.setCustomVolumeStatus(true);
+                    } else {
+                        ALOGD("mUseCustomVolume false");
+                    }
+		#endif
                 }
                 addOutput(output, outputDesc);
                 setOutputDevice(outputDesc,
@@ -5069,7 +5099,18 @@ float AudioPolicyManager::computeVolume(audio_stream_type_t stream,
                                         int index,
                                         audio_devices_t device)
 {
+#ifdef MTK_HARDWARE
+    float volumeDB;
+    if (mAudioPolicyVendorControl.getCustomVolumeStatus()) {
+            volumeDB = Volume::AmplToDb(computeCustomVolume(stream, index, device));
+    } else {
+        ALOGW("%s,not Customer Volume, Using Android Volume Curve",__FUNCTION__);
+            volumeDB = mVolumeCurves->volIndexToDb(stream, Volume::getDeviceCategory(device), index);
+    }
+    ALOGD("%s streamtype [%d],index [%d],device [0x%x], volumeDb [%f]",__FUNCTION__,stream,index,device,volumeDB);
+#else
     float volumeDB = mVolumeCurves->volIndexToDb(stream, Volume::getDeviceCategory(device), index);
+#endif
 
     // handle the case of accessibility active while a ringtone is playing: if the ringtone is much
     // louder than the accessibility prompt, the prompt cannot be heard, thus masking the touch
@@ -5177,7 +5218,16 @@ status_t AudioPolicyManager::checkAndSetVolume(audio_stream_type_t stream,
         float voiceVolume;
         // Force voice volume to max for bluetooth SCO as volume is managed by the headset
         if (stream == AUDIO_STREAM_VOICE_CALL) {
+#ifdef MTK_HARDWARE
+            if (mAudioPolicyVendorControl.getCustomVolumeStatus()) {
+                voiceVolume = computeCustomVolume(stream, index, device);
+            } else {
+            voiceVolume = (float)index/(float)mVolumeCurves->getVolumeIndexMax(stream);
+            }
+#else
             voiceVolume = (float)index/(float)mVolumeCurves->getVolumeIndexMax(stream);
+#endif
+
         } else {
             voiceVolume = 1.0;
         }
@@ -5637,4 +5687,297 @@ void AudioPolicyManager::updateAudioProfiles(audio_devices_t device,
     }
 }
 
+status_t AudioPolicyManager::SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4)
+{
+    audio_devices_t primaryOutDevices = mPrimaryOutput->device();
+    audio_devices_t curDevice =Volume::getDeviceForVolume(mPrimaryOutput->device());
+    ALOGD("SetPolicyManagerParameters par1 = %d par2 = %d par3 = %d par4 = %d curDevice = 0x%x",par1,par2,par3,par4,curDevice);
+    status_t volStatus;
+    switch(par1) {
+        case POLICY_LOAD_VOLUME:{
+            LoadCustomVolume();
+            for(int i =0; i<AUDIO_STREAM_CNT;i++) {
+                if (i == AUDIO_STREAM_PATCH) {
+                    continue;
+                }
+                volStatus =checkAndSetVolume((audio_stream_type_t)i, mVolumeCurves->getVolumeIndex((audio_stream_type_t) i, primaryOutDevices), mPrimaryOutput,primaryOutDevices,50,true);
+            }
+            break;
+         }
+        default:
+            break;
+    }
+
+    return NO_ERROR;
+}
+
+float AudioPolicyManager::linearToLog(int volume)
+{
+    return volume ? exp(float(fCUSTOM_VOLUME_MAPPING_STEP - volume) * fBConvert) : 0;
+}
+
+int AudioPolicyManager::logToLinear(float volume)
+{
+    return volume ? fCUSTOM_VOLUME_MAPPING_STEP - int(fBConvertInverse * log(volume) + 0.5) : 0;
+}
+
+int AudioPolicyManager::mapVol(float &vol, float unitstep)
+{
+    int index = (vol+0.5)/unitstep;
+    vol -= (index*unitstep);
+    return index;
+}
+
+int AudioPolicyManager::mapping_Voice_vol(float &vol, float unitstep)
+{
+    #define ROUNDING_NUM (1)
+
+    if (vol < unitstep) {
+        return 1;
+    }
+    if (vol < (unitstep*2 + ROUNDING_NUM)) {
+        vol -= unitstep;
+        return 2;
+    } else if (vol < (unitstep*3 + ROUNDING_NUM)) {
+        vol -= unitstep*2;
+        return 3;
+    } else if (vol < (unitstep*4 + ROUNDING_NUM)) {
+        vol -= unitstep*3;
+        return 4;
+    } else if (vol < (unitstep*5 + ROUNDING_NUM)) {
+        vol -= unitstep*4;
+        return 5;
+    } else if (vol < (unitstep*6 + ROUNDING_NUM)) {
+        vol -= unitstep*5;
+        return 6;
+    } else if (vol < (unitstep*7 + ROUNDING_NUM)) {
+        vol -= unitstep*6;
+        return 7;
+    } else {
+        ALOGW("vole = %f unitstep = %f",vol,unitstep);
+        return 0;
+    }
+}
+
+
+int AudioPolicyManager::getStreamMaxLevels(int stream)
+{
+    return (int) mAudioCustVolumeTable.audiovolume_level[stream];
+}
+
+// this function will map vol 0~100 , base on customvolume map to 0~255 , and do linear calculation to set mastervolume
+float AudioPolicyManager::mapVoltoCustomVol(unsigned char array[], int volmin, int volmax,float &vol , int stream)
+{
+    MTK_ALOGV("+MapVoltoCustomVol vol = %f stream = %d volmin = %d volmax = %d",vol,stream,volmin,volmax);
+    CustomVolumeType vol_stream = (CustomVolumeType) stream;
+    audio_stream_type_t audio_stream = (audio_stream_type_t) stream;
+
+    if (vol_stream == CUSTOM_VOL_TYPE_VOICE_CALL || vol_stream == CUSTOM_VOL_TYPE_SIP) {
+        return mapVoiceVoltoCustomVol(array,volmin,volmax,vol,stream);
+    } else if (vol_stream >= CUSTOM_NUM_OF_VOL_TYPE || vol_stream < CUSTOM_VOL_TYPE_VOICE_CALL) {
+        ALOGE("%s %d Error : stream = %d",__FUNCTION__,__LINE__,stream);
+        audio_stream = AUDIO_STREAM_MUSIC;
+        vol_stream = CUSTOM_VOL_TYPE_MUSIC;
+    }
+
+    float volume =0.0;
+    if (vol == 0) {
+        volume = vol;
+        return 0;
+    } else {    // map volume value to custom volume
+        int dMaxLevels = getStreamMaxLevels(vol_stream);
+        int streamDescmIndexMax = mVolumeCurves->getVolumeIndexMax(audio_stream);// streamDesc.getVolumeIndexMax();
+        if (dMaxLevels <= 0) {
+            ALOGE("%s %d Error : dMaxLevels = %d",__FUNCTION__,__LINE__,dMaxLevels);
+            dMaxLevels = 1;
+        }
+        if (streamDescmIndexMax <= 0) {
+            ALOGE("%s %d Error : streamDescmIndexMax = %d",__FUNCTION__,__LINE__,streamDescmIndexMax);
+            streamDescmIndexMax = 1;
+        }
+
+        float unitstep = fCUSTOM_VOLUME_MAPPING_STEP/dMaxLevels;
+        if (vol < fCUSTOM_VOLUME_MAPPING_STEP/streamDescmIndexMax) {
+            volume = array[0];
+            vol = volume;
+            return volume;
+        }
+        int Index = mapVol(vol, unitstep);
+        float Remind = (1.0 - (float)vol/unitstep);
+        if (Index != 0) {
+            volume = ((array[Index]  - (array[Index] - array[Index-1]) * Remind)+0.5);
+        } else {
+            volume = 0;
+        }
+        MTK_ALOGVV("%s vol [%f] unitstep [%f] Index [%d] Remind [%f] volume [%f]",__FUNCTION__,vol,unitstep,Index,Remind,volume);
+    }
+    // -----clamp for volume
+    if ( volume > 253.0) {
+        volume = fCUSTOM_VOLUME_MAPPING_STEP;
+    } else if ( volume <= array[0]) {
+        volume = array[0];
+    }
+    vol = volume;
+    MTK_ALOGVV("%s volume [%f] vol [%f]",__FUNCTION__,volume,vol);
+    return volume;
+}
+
+// this function will map vol 0~100 , base on customvolume map to 0~255 , and do linear calculation to set mastervolume
+float AudioPolicyManager::mapVoiceVoltoCustomVol(unsigned char array[], int volmin __unused, int volmax __unused, float &vol, int vol_stream_type)
+{
+    vol = (int)vol;
+    float volume = 0.0;
+//  StreamDescriptor &streamDesc = mStreams.valueFor((audio_stream_type_t)AUDIO_STREAM_VOICE_CALL);//mStreams[AUDIO_STREAM_VOICE_CALL];
+    if (vol == 0) {
+        volume = array[0];
+    } else {
+        int dMaxIndex = getStreamMaxLevels(AUDIO_STREAM_VOICE_CALL)-1;
+        if (dMaxIndex < 0) {
+            ALOGE("%s %d Error : dMaxIndex = %d",__FUNCTION__,__LINE__,dMaxIndex);
+            dMaxIndex = 1;
+        }
+        if (vol >= fCUSTOM_VOLUME_MAPPING_STEP) {
+            volume = array[dMaxIndex];
+            MTK_ALOGVV("%s volumecheck stream = %d index = %d volume = %f",__FUNCTION__,AUDIO_STREAM_VOICE_CALL,dMaxIndex,volume);
+        } else {
+            double unitstep = fCUSTOM_VOLUME_MAPPING_STEP /dMaxIndex;
+            int Index = mapping_Voice_vol(vol, unitstep);
+            // boundary for array
+            if (Index >= dMaxIndex) {
+                Index = dMaxIndex;
+            }
+            float Remind = (1.0 - (float)vol/unitstep) ;
+            if (Index != 0) {
+                volume = (array[Index]  - (array[Index] - array[Index- 1]) * Remind)+0.5;
+            } else {
+                volume =0;
+            }
+            MTK_ALOGVV("%s volumecheck stream = %d index = %d volume = %f",__FUNCTION__,AUDIO_STREAM_VOICE_CALL,Index,volume);
+            MTK_ALOGVV("%s dMaxIndex [%d] vol [%f] unitstep [%f] Index [%d] Remind [%f] volume [%f]",__FUNCTION__,dMaxIndex,vol,unitstep,Index,Remind,volume);
+        }
+    }
+
+     if ( volume > CUSTOM_VOICE_VOLUME_MAX && vol_stream_type == CUSTOM_VOL_TYPE_VOICE_CALL) {
+         volume = CUSTOM_VOICE_VOLUME_MAX;
+     }
+     else if ( volume > 253.0) {
+        volume = fCUSTOM_VOLUME_MAPPING_STEP;
+     }
+     else if ( volume <= array[0]) {
+         volume = array[0];
+     }
+
+     vol = volume;
+     if ( vol_stream_type == CUSTOM_VOL_TYPE_VOICE_CALL) {
+     float degradeDb = (CUSTOM_VOICE_VOLUME_MAX-vol)/CUSTOM_VOICE_ONEDB_STEP;
+     MTK_ALOGVV("%s volume [%f] degradeDb [%f]",__FUNCTION__,volume,degradeDb);
+     vol = fCUSTOM_VOLUME_MAPPING_STEP - (degradeDb*4);
+     }
+     MTK_ALOGVV("%s volume [%f] vol [%f]",__FUNCTION__,volume,vol);
+     return volume;
+}
+
+float AudioPolicyManager::computeCustomVolume(int stream, int index, audio_devices_t device)
+{
+    // check if force use exist , get output device for certain mode
+    device_category deviceCategory = Volume::getDeviceCategory(device);
+    // compute custom volume
+    float volume =0.0;
+    int volmax=0 , volmin =0;
+    int custom_vol_device_mode,audiovolume_steamtype;
+    int dMaxStepIndex = 0;
+
+    MTK_ALOGVV("%s volumecheck stream = %d index = %d device = %d",__FUNCTION__,stream,index,device);
+
+    if (mAudioPolicyVendorControl.getVoiceReplaceDTMFStatus() && stream == AUDIO_STREAM_DTMF) {
+        //normalize new index from 0~15(audio) to 0~6(voice)
+        float DTMFvolInt = (fCUSTOM_VOLUME_MAPPING_STEP * (index - mVolumeCurves->getVolumeIndexMin(AUDIO_STREAM_DTMF))) / (mVolumeCurves->getVolumeIndexMax(AUDIO_STREAM_DTMF) - mVolumeCurves->getVolumeIndexMin(AUDIO_STREAM_DTMF));
+        index = (DTMFvolInt*(mVolumeCurves->getVolumeIndexMax(AUDIO_STREAM_VOICE_CALL) - mVolumeCurves->getVolumeIndexMin(AUDIO_STREAM_VOICE_CALL))/ (fCUSTOM_VOLUME_MAPPING_STEP)) + mVolumeCurves->getVolumeIndexMin(AUDIO_STREAM_VOICE_CALL);
+        MTK_ALOGVV("volumecheck refine DTMF index [%d] to Voice index [%d]",tempindex,index);
+        stream = (int) AUDIO_STREAM_VOICE_CALL;
+    }
+
+    float volInt = (fCUSTOM_VOLUME_MAPPING_STEP * (index - mVolumeCurves->getVolumeIndexMin((audio_stream_type_t)stream))) / (mVolumeCurves->getVolumeIndexMax((audio_stream_type_t)stream) - mVolumeCurves->getVolumeIndexMin((audio_stream_type_t)stream));
+
+    if (deviceCategory == DEVICE_CATEGORY_SPEAKER) {
+        custom_vol_device_mode = CUSTOM_VOLUME_SPEAKER_MODE;
+        if ((device & AUDIO_DEVICE_OUT_WIRED_HEADSET)||
+             (device & AUDIO_DEVICE_OUT_WIRED_HEADPHONE))
+                custom_vol_device_mode = CUSTOM_VOLUME_HEADSET_SPEAKER_MODE;
+    } else if (deviceCategory == DEVICE_CATEGORY_HEADSET) {
+        custom_vol_device_mode = CUSTOM_VOLUME_HEADSET_MODE;
+    } else if (deviceCategory == DEVICE_CATEGORY_EARPIECE) {
+        custom_vol_device_mode = CUSTOM_VOLUME_NORMAL_MODE;
+    } else {
+        custom_vol_device_mode = CUSTOM_VOLUME_HEADSET_SPEAKER_MODE;
+    }
+
+    if ((stream == (int) AUDIO_STREAM_VOICE_CALL) && (mEngine->getPhoneState() == AUDIO_MODE_IN_COMMUNICATION)) {
+        audiovolume_steamtype = (int) CUSTOM_VOL_TYPE_SIP;
+    } else if (stream >= (int) AUDIO_STREAM_VOICE_CALL && stream < (int) AUDIO_STREAM_CNT) {
+        audiovolume_steamtype = stream;
+    } else {
+        audiovolume_steamtype = (int) CUSTOM_VOL_TYPE_MUSIC;
+        ALOGE("%s %d Error : audiovolume_steamtype = %d",__FUNCTION__,__LINE__,audiovolume_steamtype);
+    }
+
+    dMaxStepIndex = getStreamMaxLevels(audiovolume_steamtype) - 1;
+
+    if (dMaxStepIndex > CUSTOM_AUDIO_MAX_VOLUME_STEP - 1) {
+        ALOGE("%s %d Error : dMaxStepIndex = %d",__FUNCTION__,__LINE__,dMaxStepIndex);
+        dMaxStepIndex = CUSTOM_AUDIO_MAX_VOLUME_STEP - 1;
+    } else if (dMaxStepIndex < 0) {
+        ALOGE("%s %d Error : dMaxStepIndex = %d",__FUNCTION__,__LINE__,dMaxStepIndex);
+        dMaxStepIndex = 0;
+    }
+
+    volmax =mAudioCustVolumeTable.audiovolume_steamtype[audiovolume_steamtype][custom_vol_device_mode][dMaxStepIndex];
+    volmin = mAudioCustVolumeTable.audiovolume_steamtype[audiovolume_steamtype][custom_vol_device_mode][0];
+    MTK_ALOGVV("%s audiovolume_steamtype %d custom_vol_device_mode %d stream %d", __FUNCTION__, audiovolume_steamtype, custom_vol_device_mode, audiovolume_steamtype);
+    MTK_ALOGVV("%s getStreamMaxLevels(stream) %d volmax %d volmin %d volInt %f index %d", __FUNCTION__, getStreamMaxLevels(audiovolume_steamtype), volmax, volmin, volInt, index);
+    volume = mapVoltoCustomVol(mAudioCustVolumeTable.audiovolume_steamtype[audiovolume_steamtype][custom_vol_device_mode], volmin, volmax,volInt, audiovolume_steamtype);
+
+    volume = linearToLog(volInt);
+    ALOGV("stream = %d after computeCustomVolume , volInt = %f volume = %f volmin = %d volmax = %d", audiovolume_steamtype, volInt, volume, volmin, volmax);
+    return volume;
+}
+
+void AudioPolicyManager::LoadCustomVolume()
+{
+    ALOGD("LoadCustomVolume Audio_Ver1_Custom_Volume");
+    //android::GetVolumeVer1ParamFromNV(&Audio_Ver1_Custom_Volume);
+
+    mAudioCustVolumeTable.bRev = CUSTOM_VOLUME_REV_1;
+    mAudioCustVolumeTable.bReady = 0;
+
+    MTK_ALOGVV("Before Update");
+    for (int i=0;i<CUSTOM_NUM_OF_VOL_TYPE;i++) {
+        MTK_ALOGVV("StreamType %d",i);
+        for (int j=0;j<CUSTOM_NUM_OF_VOL_MODE;j++) {
+            MTK_ALOGVV("DeviceType %d",j);
+            for (int k=0;k<CUSTOM_AUDIO_MAX_VOLUME_STEP;k++) {
+                MTK_ALOGVV("[IDX]:[Value] %d,%d",k,mAudioCustVolumeTable.audiovolume_steamtype[i][j][k]);
+            }
+        }
+    }
+    mpClientInterface->getCustomAudioVolume(&mAudioCustVolumeTable);
+    if (mAudioCustVolumeTable.bReady!=0) {
+        ALOGD("mUseCustomVolume true");
+        mAudioPolicyVendorControl.setCustomVolumeStatus(true);
+    } else {
+        ALOGD("mUseCustomVolume false");
+    }
+    MTK_ALOGVV("After Update");
+    for (int i=0;i<CUSTOM_NUM_OF_VOL_TYPE;i++) {
+        MTK_ALOGVV("StreamType %d",i);
+        for (int j=0;j<CUSTOM_NUM_OF_VOL_MODE;j++) {
+            MTK_ALOGVV("DeviceType %d",j);
+            for (int k=0;k<CUSTOM_AUDIO_MAX_VOLUME_STEP;k++) {
+                MTK_ALOGVV("[IDX]:[Value] %d,%d",k,mAudioCustVolumeTable.audiovolume_steamtype[i][j][k]);
+            }
+        }
+    }
+
+}
+
 }; // namespace android
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.h b/services/audiopolicy/managerdefault/AudioPolicyManager.h
index 78f9e65..542bc4a 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.h
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.h
@@ -62,6 +62,10 @@
 #include <SoundTriggerSession.h>
 #include <SessionRoute.h>
 #include <VolumeCurve.h>
+#include <AudioPolicyVendorControl.h>
+#include <utils/threads.h>
+#include <AudioCustParam.h>
+#include <AudioCustomVolume.h>
 
 namespace android {
 
@@ -216,6 +220,7 @@ public:
         virtual status_t dump(int fd);
 
         virtual bool isOffloadSupported(const audio_offload_info_t& offloadInfo);
+        virtual status_t SetPolicyManagerParameters(int par1,int par2 ,int par3,int par4);
 
         virtual status_t listAudioPorts(audio_port_role_t role,
                                         audio_port_type_t type,
@@ -294,6 +299,10 @@ protected:
         {
             return mDefaultOutputDevice;
         }
+        virtual AudioPolicyVendorControl &getAudioPolicyVendorControl()
+        {
+            return mAudioPolicyVendorControl;
+        }
 protected:
         void addOutput(audio_io_handle_t output, sp<SwAudioOutputDescriptor> outputDesc);
         void removeOutput(audio_io_handle_t output);
@@ -607,6 +616,8 @@ protected:
 
         // Audio Policy Engine Interface.
         AudioPolicyManagerInterface *mEngine;
+        AudioPolicyVendorControl mAudioPolicyVendorControl;
+        void LoadCustomVolume(void);
 private:
         // Add or remove AC3 DTS encodings based on user preferences.
         void filterSurroundFormats(FormatVector *formatsPtr);
@@ -680,6 +691,17 @@ protected:
 #include "DolbyAudioPolicy.h"
         DolbyAudioPolicy mDolbyAudioPolicy;
 #endif // DOLBY_END
+
+private:
+        float linearToLog(int volume);
+        int logToLinear(float volume);
+        int mapVol(float &vol, float unitstep);
+        int mapping_Voice_vol(float &vol, float unitstep);
+        float computeCustomVolume(int stream, int index, audio_devices_t device);
+        int getStreamMaxLevels(int  stream);
+            float mapVoiceVoltoCustomVol(unsigned char array[], int volmin, int volmax, float &vol, int vol_stream_type);
+        float mapVoltoCustomVol(unsigned char array[], int volmin, int volmax,float &vol , int stream);
+		AUDIO_CUSTOM_VOLUME_STRUCT mAudioCustVolumeTable;
 };
 
 };
diff --git a/services/audiopolicy/service/AudioPolicyClientImpl.cpp b/services/audiopolicy/service/AudioPolicyClientImpl.cpp
index e0d977a..4ea843f 100644
--- a/services/audiopolicy/service/AudioPolicyClientImpl.cpp
+++ b/services/audiopolicy/service/AudioPolicyClientImpl.cpp
@@ -240,4 +240,13 @@ audio_unique_id_t AudioPolicyService::AudioPolicyClient::newAudioUniqueId(audio_
     return AudioSystem::newAudioUniqueId(use);
 }
 
+status_t AudioPolicyService::AudioPolicyClient::getCustomAudioVolume(void* pCustomVol)
+{
+#ifdef MTK_HARDWARE
+    return mAudioPolicyService->getCustomAudioVolume(pCustomVol);
+#else
+    return INVALID_OPERATION;
+#endif
+}
+
 }; // namespace android
diff --git a/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp b/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
index 8bc50b0..bd4e8ef 100644
--- a/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
+++ b/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
@@ -778,6 +778,20 @@ status_t AudioPolicyService::getMasterMono(bool *mono)
     return mAudioPolicyManager->getMasterMono(mono);
 }
 
+status_t AudioPolicyService::SetPolicyManagerParameters(int par1, int par2, int par3, int par4)
+{
+#ifdef MTK_HARDWARE
+    Mutex::Autolock _l(mLock);
+    if (mAudioPolicyManager == NULL) {
+        return NO_INIT;
+    }
+    return mAudioPolicyManager->SetPolicyManagerParameters(par1, par2, par3, par4);
+#else
+    return 0;
+#endif
+
+}
+
 status_t AudioPolicyService::listAudioSessions(audio_stream_type_t streams,
                                                Vector< sp<AudioSessionInfo>> &sessions)
 {
diff --git a/services/audiopolicy/service/AudioPolicyService.cpp b/services/audiopolicy/service/AudioPolicyService.cpp
index 2b3ed26..88d6bda 100644
--- a/services/audiopolicy/service/AudioPolicyService.cpp
+++ b/services/audiopolicy/service/AudioPolicyService.cpp
@@ -41,6 +41,7 @@
 #include <system/audio.h>
 #include <system/audio_policy.h>
 #include <hardware/audio_policy.h>
+#include <AudioPolicyParameters.h>
 
 namespace android {
 
@@ -58,6 +59,39 @@ namespace {
 };
 #endif
 
+// mtk start
+status_t AudioPolicyService::getCustomAudioVolume(void* pCustomVol)
+{
+#ifdef MTK_HARDWARE
+    return mAudioCommandThread->getCustomAudioVolumeCommand(pCustomVol);
+#else
+    return INVALID_OPERATION;
+#endif
+}
+
+status_t     AudioPolicyService::AudioCommandThread::getCustomAudioVolumeCommand(void* pCustomVol)
+{
+#ifdef MTK_HARDWARE
+    status_t status = NO_ERROR;
+    sp<AudioCommand> command = new AudioCommand();
+    command->mCommand = GET_CUSTOM_AUDIO_VOLUME;
+
+    GetCustomAudioVolumeData *data = new GetCustomAudioVolumeData();
+    memcpy(&(data->mVolConfig),pCustomVol,sizeof(AUDIO_CUSTOM_VOLUME_STRUCT));
+    command->mParam = data;
+    command->mWaitStatus = true;
+    ALOGD("AudioCommandThread() adding set getCustomAudioVolume");
+    status = sendCommand(command);
+    if (status == NO_ERROR) {
+        memcpy(pCustomVol,&(data->mVolConfig),sizeof(AUDIO_CUSTOM_VOLUME_STRUCT));
+    }
+    return status;
+#else
+    return INVALID_OPERATION;
+#endif
+}
+// mtk end
+
 // ----------------------------------------------------------------------------
 
 AudioPolicyService::AudioPolicyService()
@@ -94,7 +128,7 @@ void AudioPolicyService::onFirstRef()
         }
 
         rc = mpAudioPolicyDev->create_audio_policy(mpAudioPolicyDev, &aps_ops, this,
-                                                   &mpAudioPolicy);
+                                                   /*<mtk_add*/(struct audio_policy **)/*mtk_add>*/&mpAudioPolicy);
         ALOGE_IF(rc, "couldn't create audio policy (%s)", strerror(-rc));
         if (rc) {
             return;
@@ -661,6 +695,19 @@ bool AudioPolicyService::AudioCommandThread::threadLoop()
                     mLock.lock();
                     } break;
 
+#ifdef MTK_HARDWARE
+                case GET_CUSTOM_AUDIO_VOLUME: {
+                    GetCustomAudioVolumeData *data = (GetCustomAudioVolumeData *)command->mParam.get();
+                    ALOGV("AudioCommandThread() processing GET_CUSTOM_AUDIO_VOLUME");
+                    sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
+                    if (af == 0) {
+                        command->mStatus = PERMISSION_DENIED;
+                    } else {
+                        command->mStatus = af->GetAudioData(GET_AUDIO_POLICY_VOL_FROM_VER1_DATA,sizeof(AUDIO_CUSTOM_VOLUME_STRUCT),&(data->mVolConfig));
+                    }
+                    ALOGV("-AudioCommandThread %d",command->mCommand);
+                    } break;
+#endif
                 default:
                     ALOGW("AudioCommandThread() unknown command %d", command->mCommand);
                 }
diff --git a/services/audiopolicy/service/AudioPolicyService.h b/services/audiopolicy/service/AudioPolicyService.h
index fec95cc..c66377f 100644
--- a/services/audiopolicy/service/AudioPolicyService.h
+++ b/services/audiopolicy/service/AudioPolicyService.h
@@ -36,6 +36,7 @@
 #endif
 #include "AudioPolicyEffects.h"
 #include "managerdefault/AudioPolicyManager.h"
+#include <audio_policy_mtk.h>
 
 
 namespace android {
@@ -136,6 +137,8 @@ public:
     virtual bool isStreamActive(audio_stream_type_t stream, uint32_t inPastMs = 0) const;
     virtual bool isStreamActiveRemotely(audio_stream_type_t stream, uint32_t inPastMs = 0) const;
     virtual bool isSourceActive(audio_source_t source) const;
+    virtual status_t SetPolicyManagerParameters(int par1, int par2, int par3, int par4);
+    virtual status_t getCustomAudioVolume(void* pCustomVol);
 
     virtual status_t queryDefaultPreProcessing(audio_session_t audioSession,
                                               effect_descriptor_t *descriptors,
@@ -279,6 +282,7 @@ private:
             DYN_POLICY_MIX_STATE_UPDATE,
             RECORDING_CONFIGURATION_UPDATE,
             EFFECT_SESSION_UPDATE,
+            GET_CUSTOM_AUDIO_VOLUME,
         };
 
         AudioCommandThread (String8 name, const wp<AudioPolicyService>& service);
@@ -328,6 +332,7 @@ private:
                                                         audio_patch_handle_t patchHandle);
                     void        insertCommand_l(AudioCommand *command, int delayMs = 0);
                     void        effectSessionUpdateCommand(sp<AudioSessionInfo>& info, bool added);
+                    status_t    getCustomAudioVolumeCommand(void* pCustomVol);
 
     private:
         class AudioCommandData;
@@ -440,6 +445,10 @@ private:
             bool mAdded;
         };
 
+        class GetCustomAudioVolumeData : public AudioCommandData {
+        public:
+            AUDIO_CUSTOM_VOLUME_STRUCT mVolConfig;
+        };
         Mutex   mLock;
         Condition mWaitWorkCV;
         Vector < sp<AudioCommand> > mAudioCommands; // list of pending commands
@@ -554,6 +563,8 @@ private:
         virtual audio_unique_id_t newAudioUniqueId(audio_unique_id_use_t use);
 
         virtual void onOutputSessionEffectsUpdate(sp<AudioSessionInfo>& info, bool added);
+        
+        virtual status_t getCustomAudioVolume(void* pCustomVol);
 
 
      private:
@@ -607,7 +618,10 @@ private:
     sp<AudioCommandThread> mTonePlaybackThread;     // tone playback thread
     sp<AudioCommandThread> mOutputCommandThread;    // process stop and release output
     struct audio_policy_device *mpAudioPolicyDev;
+#if 0 // zormax add, replace it with audio_policy_mtk
     struct audio_policy *mpAudioPolicy;
+#endif
+    struct audio_policy_mtk *mpAudioPolicy;
     AudioPolicyInterface *mAudioPolicyManager;
     AudioPolicyClient *mAudioPolicyClient;
 
-- 
1.9.1

